//TCP Pinger (2 Clients)

#include <unistd.h> 
#include <stdio.h> 
#include <sys/socket.h> 
#include <stdlib.h> 
#include <netinet/in.h> 
#include <string.h>
#include <pthread.h>
#include <iostream>

#define PORT	11000

//Sources: 
// https://www.geeksforgeeks.org/socket-programming-in-cc-handling-multiple-clients-on-server-without-multi-threading/
// https://dzone.com/articles/parallel-tcpip-socket-server-with-multi-threading

char inMessageA[2048];
char inMessageB[2048];
char buffer[4112];
pthread_t tid[2];
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

//Receives a message and responds to a single client (Used by two threads)
void * clientThread(void *fd){

	int clientSocket = *((int *) fd);

	//Receives a message and places it in the appropriate buffer based on which
	//came first
	pthread_mutex_lock(&lock);
	if(inMessageA[0] == '\0'){
		recv(clientSocket, inMessageA, 2048, 0);
		std::cout << "\nFirst message: " << inMessageA << "\n";
	}else{
		recv(clientSocket, inMessageB, 2048, 0);
		std::cout << "\nSecond message: " << inMessageB << "\n";
	}
	pthread_mutex_unlock(&lock);

	//Allows the other thread time to catch up to ensure a message is placed in
	//the second buffer
	sleep(2);

	//Generates and sends the server's output message
	char *outMessage = (char*) malloc(sizeof(inMessageA) + (2048+16));
	strcpy(outMessage, inMessageA);
	strcat(outMessage, "received before ");
	strcat(outMessage, inMessageB);
	strcpy(buffer, outMessage);

	send(clientSocket,outMessage,strlen(outMessage),0);

	close(clientSocket);
	pthread_exit(NULL);
}

int main(){
	//Used as a conditional later on...
	inMessageA[0] = '\0';

	int serverSockfd, clientSockfdA, clientSockfdB, maxClients;
	socklen_t len;
	struct sockaddr_in ServerSock,clientSock;

	//Max amount of clients this server can handle
	maxClients = 2;

	memset(&ServerSock, 0, sizeof(ServerSock));

	//Creation of a TCP socket
	serverSockfd = socket(AF_INET, SOCK_STREAM, 0);
	ServerSock.sin_family = AF_INET;
	ServerSock.sin_addr.s_addr = INADDR_ANY;
	ServerSock.sin_port = htons(PORT);

	//Binds socket to specified port
	bind(serverSockfd, (struct sockaddr *) &ServerSock, sizeof(ServerSock));

	//Listens for clients attempting to connect
	listen(serverSockfd, maxClients);

	int i = 0;

	len = sizeof(clientSock);

	//Waits until both clients are connected before continuing
	clientSockfdA = accept(serverSockfd, (struct sockaddr *) &clientSock, &len);

	clientSockfdB = accept(serverSockfd, (struct sockaddr *) &clientSock, &len);

	//Creates the two threads that will interact with the clients
	pthread_create(&tid[i++], NULL, clientThread, &clientSockfdA);
	pthread_create(&tid[i++], NULL, clientThread, &clientSockfdB);

	for(int j=0;j<2;j++){
		//Waits for both threads to finish
		pthread_join(tid[j],NULL);
	}

	//Outputs the message generated by the server to the terminal
	std::cout << "\n" << buffer << "\n";

	std::cout << "\n" << "Sent acknowledgement to both X and Y" << "\n";
		
	return 0;
}

	

	
